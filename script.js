// 1. Є наступний код:
/*
console.log('start');

const promise1 = new Promise((resolve, reject) => {
console.log(1)
resolve(2)
})

promise1.then(res => {
console.log(res)
})

console.log('end');
*/

// Яким буде результат його виклику? Чому? Опишіть як працює цей код.

/*
Результат виклику: 

start
1
end
2

*/
/*

1. console.log('start'); виводить рядок "start" в консоль.

2.  Створюється об'єкт обіцянка (Promise) promise1. 
    В конструктор обіцянки передається функція з двома аргументами: resolve та reject. 
    resolve - це функція, яка викликається, коли обіцянка успішно виконана. 
    reject - це функція, яка викликається, коли обіцянка відхиляється. 
    В середині цієї функції відбувається виведення рядка "1" у консоль та виклик функції resolve(2). 
    Це означає, що обіцянка promise1 буде виконана із результатом 2.

3.  promise1.then(res => { console.log(res) }); - ця конструкція називається ланцюжком обробки. 
    Вона говорить про те, що коли обіцянка promise1 буде виконана (у нашому випадку буде виконана відразу), 
    функція (res => { console.log(res) }) буде викликана з результатом обіцянки (який у нас дорівнює 2). 
    Таким чином, в консоль буде виведено "2".

4. console.log('end'); виводить рядок "end" в консоль.
*/

// 2. Є наступний код:
/*
Promise.resolve(1)
		.then((x) => x + 1)
		.then((x) => { throw new Error('My Error') })
		.catch(() => 1)
		.then((x) => x + 1)
		.then((x) => console.log(x))
		.catch(console.error)
*/

// Яким буде результат його виклику? Чому? Опишіть як працює цей код.

/*
Результат виклику: 

2

*/
/*

1. Створюється обіцянка зі значенням 1.

2. Перший then приймає це значення 1 та додає до нього 1, (1 + 1 = 2) і передає далі. 

3. Другий then отримує значення 2, але потім спрацьовує помилка throw new Error('My Error').

4. Призначений для цього catch перехоплює помилку, але не повертає жодного значення.

5. Наступний then отримує значення, яке не було змінено попередніми обробниками, але тут відбувається додавання 1 до нього (1 + 1 = 2) і передається далі.

6. Останній then отримує значення 2, яке передавалося попереднім обробником, і виводить його в консоль.
*/

// 3. Є наступний код:
/*
const promise = new Promise(res => res(2)); 
	promise.then(v => {
	        console.log(v);
	        return v * 2;
	    })
	    .then(v => {
	        console.log(v);
	        return v * 2;
	    })
	    .finally(v => {
	        console.log(v);
	        return v * 2;
	    })
	    .then(v => {
	        console.log(v);
	    });
*/

// Яким буде результат його виклику? Чому? Опишіть як працює цей код.

/*
Результат виклику: 

2
4
undefined
8

*/
/*

1. Створюється об'єкт promise за допомогою конструктора Promise, і йому передається функція, яка викликає res(2) - це означає, що обіцянка (promise) виконається зі значенням 2.

2. Потім додається обробник до обіцянки за допомогою .then(). У цьому обробнику виводиться значення 2, а потім повертається результат обчислення v * 2, тобто 4.

3. Далі до отриманої попередньої обіцянки (яка має значення 4) додається ще один обробник через .then(). 
   У цьому обробнику виводиться значення 4, а потім повертається результат обчислення v * 2, тобто знову 8.

4. Використання методу .finally() виконується незалежно від того, чи обіцянка успішно виконалася чи ні, і не отримує значення з попереднього обробника. 
   Тому в консоль виводиться undefined.

   Метод .finally() в даному випадку не впливає на значення, яке передається в наступний .then().

5. Останній обробник .then() отримує значення 8 (з попереднього обробника) і виводить його в консоль.
*/